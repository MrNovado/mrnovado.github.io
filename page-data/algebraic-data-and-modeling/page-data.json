{"componentChunkName":"component---node-modules-gatsby-theme-chronoblog-src-templates-post-js","path":"/algebraic-data-and-modeling/","result":{"data":{"mdx":{"id":"2fdc5759-b59a-5402-8767-b741ade6d45c","excerpt":"I've been trying to finish this article for a few weeks now, but just couldn't get it done. The major thing that I've been trying to sellâ€¦","frontmatter":{"title":"Algebraic data","date":"2019-03-28T11:41:22.269Z","description":"Type variant and the road to happiness; algebraic data to the rescue.","tags":["code"],"cover":null},"fields":{"slug":"/algebraic-data-and-modeling/"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Algebraic data\",\n  \"date\": \"2019-03-28T11:41:22.269Z\",\n  \"category\": \"programming\",\n  \"tags\": [\"code\"],\n  \"description\": \"Type variant and the road to happiness; algebraic data to the rescue.\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I've been trying to finish this article for a few weeks now, but just couldn't get it done. The major thing that I've been trying to sell here is the idea that OOP (and class inheritance specifically) is a wonky way of coding, in that it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"forces\"), \" you (more like enables you, really) to design rigid taxonomies which are hard to change, scale poorly, hide behaviors and states, making them implicit.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"OOP design bullies you into mentality to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"get it right the first time\"), \" (or else), which is stressful and may induce \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Analysis_paralysis\"\n  }), \"analysis paralysis\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Is-a\"), \" relationships are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"the most strong ones\"), \" and are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"commitments\"), \", which, potentially, extremely hard to break.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"There is a common saying that you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"should only inherit once\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"prefer composition over inheritance\"), \".\"))), mdx(\"p\", null, \"I'm not saying inheritance is unusable, but you might consider other tools.\"), mdx(\"p\", null, \"So, instead of trying to provide a deep, simple and compelling example of why \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://youtu.be/QM1iUe6IofM\"\n  }), \"OOP is Bad\"), \" (which it still kinda isn't, but whatever), I'll just show you how cool the algebraic data (or \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/variant\"\n  }), \"variant\"), \") type is and hope you would like it too.\"), mdx(\"hr\", null), mdx(\"p\", null, \"So, remember how a class in OOP is always a container of data and behaviors? And how the only way to create class taxonomies is to use inheritance, which might stiffen you up a bit, because it makes little sense for your \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AnimalIcon\"), \" class to inherit data and behaviors from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" class?\"), mdx(\"p\", null, \"Well, with the type variant you can go like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elm\"\n  }), \"type Animal\\n    = Moo MooState\\n    | Bark BarkState\\n    | Meow MeowState\\n    | AnimalIcon AnimalURI AnimalState\\n    | UnknownAnimal\\n    | ...\\n\")), mdx(\"p\", null, \"You can create any taxonomies you want with any classes (types in this particular case) without restricting and committing to anything at all.\"), mdx(\"p\", null, \"The fact that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Moo\"), \" type is in the same category with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AnimalIcon\"), \" doesn't break anything for either of them. But now, you can potentially reason about an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AnimalIcon\"), \" in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the same(ish) context\"), \" you could about any other animal.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elm\"\n  }), \"case animal of\\n    Moo mooState ->\\n        -- doing something with the moo\\n        changeMooState mooState\\n\\n    AnimalIcon animalUri animalState ->\\n        -- doing something with the icon\\n        changeAnimalIcon animalUri animalState\\n\\n    UnknownAnimal ->\\n        -- doing something with the unknown\\n        throwATantrum\\n\\n    _ ->\\n        -- not doing anything\\n        animal\\n\")), mdx(\"p\", null, \"Which is super powerful! Not only that, but you can use type variant to create taxonomies of events as well:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elm\"\n  }), \"type AnimalMsg\\n    = AnimalInDanger DangerLevel\\n    | AnimalIsHurt Damage\\n    | AnimalEats Nutrition\\n    | AnimalPoops\\n    | AnimalRuns Speed\\n    | AnimalClicked\\n    | ...\\n\")), mdx(\"p\", null, \"And reason about them too:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elm\"\n  }), \"update msg animal =\\n    case msg of\\n        AnimalEats nutrition ->\\n            case animal of\\n                Moo mooState ->\\n                    makeMooFatBy nutrition mooState\\n\\n                AnimalIcon animalUri animalState ->\\n                    scaleIconBy nutrition animalUri animalState\\n\\n                _ -> ...\\n\\n        AnimalPoops ->\\n            case animal of\\n                Moo mooState ->\\n                    makeMooThin mooState\\n\\n                AnimalIcon animalUri animalState ->\\n                    playPoopEffect animalUri animalState\\n\\n                _ -> ...\\n\\n        AnimalClicked ->\\n            case animal of\\n                AnimalIcon animalUri _ ->\\n                    -- open uri only with Icon\\n                    openUri animalUri\\n\\n                _ ->\\n                    -- do nothing with the others\\n                    ...\\n\\n        _ -> ...\\n\")), mdx(\"p\", null, \"How cool is that? These example are sort of in pseudo-code, but if you want something more applicable, you should check \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Richard Feldman\"), \"'s \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/rtfeldman/elm-spa-example\"\n  }), \"Elm SPA\"), \" example. Start with the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm\"\n  }), \"main\"), \" module.\"), mdx(\"p\", null, \"Now, algebraic data or type variant are featured mostly in full-on functional languages, like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.haskell.org/\"\n  }), \"Haskell\"), \" or \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://elm-lang.org/\"\n  }), \"Elm\"), \". But nowadays you can also find them in hybrid languages as well, like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/advanced-types.html\"\n  }), \"Typescript\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/variant\"\n  }), \"ReasonML\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/reason-react/docs/en/state-actions-reducer\"\n  }), \"Reason-React\"), \".\"), mdx(\"p\", null, \"Typescript or Reason enable you to use variant with React:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type action =\\n  | Click\\n  | Toggle;\\n\\nlet component = ReasonReact.reducerComponent(\\\"Example\\\");\\n\\nlet make = (~greeting, _children) => {\\n  ...component,\\n  initialState: () => {count: 0, show: true},\\n\\n  reducer: (action, state) =>\\n    switch (action) {\\n    | Click => ReasonReact.Update({...state, count: state.count + 1})\\n    | Toggle => ReasonReact.Update({...state, show: !state.show})\\n    },\\n\\n  render: self => {\\n    <div>\\n      <button onClick=(_event => self.send(Click))/>\\n      <button onClick=(_event => self.send(Toggle))/>\\n      ...\\n    </div>;\\n  },\\n};\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2fdc5759-b59a-5402-8767-b741ade6d45c"}}}