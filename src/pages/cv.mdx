# Experience

I consider myself a **Web-front-end** dev, though I did a lot of mobile stuff as well. I do prefer Web for its expansive ecosystem and powerful tools. I'm in awe with **component-based architecture** and hybrid functional/object-oriented paradigms. Nowadays I'm researching fault tolerant, resilient, scalable systems; finding Elm's **'if it compiles, it works'** feature extremely appealing.

## TL;DR - exp

- I'm good at, have prod experience, and comfortable with **Web stack**: JS, [React](https://reactjs.org/), [Redux](https://redux.js.org/), [Saga](https://github.com/redux-saga/redux-saga), [Rx](https://github.com/redux-observable/redux-observable), [Electron](https://electronjs.org/).

- I have prod experience with **Android stack** (though I do not exactly find it appealing): Java/Kotlin, [RxJava](https://github.com/ReactiveX/RxJava), [Realm](https://realm.io/), [Dagger2](https://github.com/google/dagger), [Retrofit](https://square.github.io/retrofit/), [Crashlytics](https://try.crashlytics.com/), etc. _[Kotlin](https://kotlinlang.org/docs/reference/android-overview.html) really does make it all bearable_.

- I have some prod experience with: [Elm](https://elm-lang.org/), [Typescript](https://www.typescriptlang.org/samples/index.html), [GraphQL](https://graphql.org/learn/), [GatsbyJS](https://www.gatsbyjs.org/), [Emotion](https://github.com/emotion-js/emotion), [j2v8](https://github.com/eclipsesource/J2V8), [NodeJS](https://nodejs.org/en/about/), ActionScript (Flash/FlashBuilder).

- Builders/transpilers/compilers I've worked with: [Webpack](https://webpack.js.org/), [Babel](https://babeljs.io/), [Gradle](https://gradle.org/).

- I'm intrigued by: [Elm](https://elm-lang.org/), [ReasonML](https://reasonml.github.io/), [Elixir](https://elixir-lang.org/); [PWA](https://developers.google.com/web/progressive-web-apps/); [functional](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0) [paradigm](https://medium.freecodecamp.org/an-introduction-to-the-basic-principles-of-functional-programming-a2c2a15c84); [vertical front-ends](https://micro-frontends.org/).

- I also have a **Ph.D.** ([Candidate of Sciences](https://en.wikipedia.org/wiki/Candidate_of_Sciences) to be exact) in system analysis for researching ways to apply [Web ontologies](https://en.wikipedia.org/wiki/Web_Ontology_Language) (specifically **[RDF](https://en.wikipedia.org/wiki/RDF_Schema)** and **[OWL DL](https://en.wikipedia.org/wiki/Web_Ontology_Language#OWL_DL)**) to build Web applications.

- I've also crushed into [xstate](https://github.com/davidkpiano/xstate) and statecharts recently in a big way.

## TL;DR - story

Most projects are under **NDA**, so the story would be presented in somewhat broad terms.

- I started as a _project manager_ for a **small Web-studio** at my hometown in 2012. I've learned I enjoy coding more than doing manager stuff.

- I was hired by **JSC Prognoz** as a front-end junior dev and worked there from September 2013 to May 2015. **Analytics dashboard** was the main thing. We were coding in **pure JS**, no frameworks, very strict policies on style. At some point, I was helping other departments with dashboard integration and migrations, and doing a little bit of a full-stack development with **KnockoutJS**, **AngularJS**, **.NET**, **Entity Framework**.

- Mobile development was blooming and I wanted to check it out. Hired by **LTD Maugry** as a junior-Android/Web dev from November 2015 to March 2018. Was actually doing Web stuff at first, figuring out **BackboneJS**. Worked on **Android-kiosk** solutions for various presentational events after that. Was given a leading position and was trying to establish a core solution for Maugry' **audio guide** products. At some point, switched to **ElectronJS** to cut development costs for making kiosks. **ReactJS** + **ElectronJS** proved to be an extremely efficient set of tools, no regrets! Also learned to appreciate: **Gitlab** -- an amazing tool; **GraphQL** -- even though I didn't know its major selling point at the time; the comfort of **working with and leading** a small dedicated team.

- **LTD Andersen** as a Web-dev from July 2018 to February 2019. Decided Web/hybrid development is my thing; wanted to **relocate**; wanted to gain perspective in what bigger businesses are doing; wanted to work in a **product-oriented company**. Unfortunately, while I certainly gained a lot of experience working with huge **React** + **Redux** and even **Elm** apps (which is super cool, by the way), I've learned I do not particularly like doing outsource.

- 2019-2020 working for some government agencies. Very frustrating time, but also revelating as I've stumbled upon **xstate** and statecharts and there's no going back now!

---

# Story - part 1 (manager)

I actually started as a _project manager_ for a **small Web-studio** at my hometown in 2012. We had 2 full-time devs, 1 designer, a freelance content-manager and about ~40 ongoing projects in different stages of completion. So, very early on I found myself neck-deep in code trying to debug and resolve hot-issues for our clients in an attempt to clear some room for devs, so they could focus on actually building new stuff instead of drowning in legacy.

Didn't really work I think. In order to survive the studio had to constantly get new projects to work on, but the unfortunate thing was that the clients wanted (_how could they, right?_) a continuous support even after their projects are done and deployed, and at the time of signing a contract nobody actually knew what exactly that would entail.

It was suffocating: continuous support and design phases were the major pains. I tried to solve those in the most utilitarian fashion:

- by making weighted roadmaps to bring more focus into development;
- by introducing CRM and a ticket system to our clients to gate them away from the team, to actually document all needs and wants instead of making promises, and to give clients some way of interacting with us without doing it _in person_;
- I advocated stricter contracts with well-defined phases, so it wouldn't be possible for a client to be indecisive for too long and drag development time unpredictably.

The last one was dismissed in fear of missing out, and onboarding became a front-line issue. CRM implementation was clearly lacking and some clients didn't want anything to do with it, while others had to be taught to do the most basic stuff (even with their own websites/CMS as well: mostly 1C-Bitrix and WordPress at the time).

At some point, the studio hired a SEO specialist and things became even more overwhelming and even more emotional to the point that I found myself enjoying tinkering with the code of our projects more than doing anything else at all.

Devs do get it all easy: no angry phone calls all the time; mesmerizing, steady workflow; feeling of accomplishment when a project is done instead of constant fear of getting an angry phone call for whatever reason, etc.

---

# Story - part 2 (pureJS)

I relocated. I decided to try out Web-development as a dev this time. I was hired by **JSC Prognoz**, a business analytics company, and worked there from September 2013 to May 2015 as a junior front-end dev.

I was working on one of the core products, -- analytics dashboard, -- and on the core itself. Development was ticket-based; we were coding in pure JS, no frameworks, with a strict policy on style.

Almost an entire first year I was working on bug-fixes and stability investigations. After that, I started doing feature-based tasks, mostly improvements (feature-expansions) to dashboard' components: draggable layouts, various charts, sortable/filtrable tab-sheets.

At some point, our team was given a green-card to experiment with whatever we deemed interesting on our own, and our lead decided to try to reimplement a certain solution in TDD to teach the team some unit testing, as well as to see if we would be able to switch to a TDD paradigm at all.

Funnily enough, even though I very much respect the man, I guess this particular experience scar me for life. To this day I'm extremely skeptical about TDD/DDD and unit tests in general. If any paradigm or methodology is so inflexible and so unwieldy, so it requires you to **get it right the first time**, then something about it is completely and utterly wrong.

We weren't able to complete our MVP in 3 months we were given, though we still got some full-stack experience out of it, which happens to be very useful since everyone was moved to help other departments to finish their products, or to migrate to a newer core.

Working with other departments I had an opportunity to tinker with KnockoutJS, AngularJS, and Entity Framework.

The company wasn't doing so well at the time; I wanted to be able to make my own apps/solutions from start to finish, -- so I decided to move on.

---

# Story - part 3 (Android and React)

To check out an Android development. Hired by **LTD Maugry** as a junior-Android/Web dev from November 2015 to March 2018.

I started by trying to figure out and improve a legacy kiosk written on BackboneJS. It was a tough one: even though I almost completely rewrote an entire core of the app, making it an actual SPA (with a single configurable entry-point and a dedicated router), the loose model-view architecture of Backbone confused me very heavily, which resulted in a very stiff, non-scalable solution.

To this day I remember a sudden realization, that my components, which I've been crafting with love and care for an entire month, are so tightly coupled, changing one thing anywhere would require a lot of re-wiring and painful refactoring. When designer came to me and asked to move filter-component into the header of the app, physically away from an actual component that had to be filtered, -- it was like a slap on the face or a bucket of cold water.

> At the time I thought that unpredictably long and unstable design-phases were the major issue for me... But now I think they are pretty much inevitable, -- design is a flowing river and is always changing, and you can only adapt by choosing a technology that would enable easy refactoring and reconfiguration.

It turns out, how you wire your components together in an application is as much as important, as to how you encapsulate them: in functions, objects, classes, modules, services, managers, layers and so on. Don't make them a hay-stack communication-wise.

After that, I worked on a simple(ish) Android-kiosk -- an info-panel with a selection of topics one could choose to play a little video about.

There were a lot of prototypes. One of the most effective ideas was to make a carousel of continuously playing videos. But it seemed at the time the hardware wouldn't handle it even with higher compression, and thankfully, in the end, the client decided on a more simplified presentation.

This first kiosk did surprisingly well, though the hardware was unstable: the kiosk didn't appreciate being out in cold weather and under the falling snow... So it had issues with sound, touch-screen accessibility, and occasional freezing (fps stutter). Kinda funny how touch screen becomes unresponsive to click-events on cold, but still works very well with touch, so well, in fact, it also reacts to snowflakes.

Anyway, after that, I mostly worked on Android audio-guides. In a half a year or so, I was given a leading position on Android development and a team of 3.

We continued to make audio-guide solutions with indoor and/or outdoor navigation. While doing that I was trying to establish a core solution for audio-guides, in order to provide an easier foundation for our projects, so we wouldn't have to start over every time. 

> Thanks to our CTA/tech-lead we had a lot of room to experiment with different technologies and ideas in order to make solutions more stable, scalable and easier to produce.

I've been researching popular ways to architecture scalable, resilient apps, and most popular way at the time seemed to be in making a SOLID app with a clean architecture.

- I introduced Dagger2 in order to try and decouple components, so, in theory, we wouldn't have to worry about changing anything _on the fly_, if it came to that, as well as to provide a single and _clean(ish)_ way to instantiate dependencies and wire them into a graph.

- I introduced RxJava to make wiring components to data and data-transformations easier.

- I was looking for a way to opt-out of Java, if at all possible, because Java always seemed very strict, very verbose and unwieldy to me. So when Kotlin came about, I wholeheartedly advocated for it, and it turned out it was a much better language indeed.

- I decided to move away from SQL-based solutions to something more modern (and potentially easier). There wasn't much competition to Realm, and it had support for iOS, and even JS too, so we moved onto that.

- Tech-lead introduced GraphQL trying to move away from REST and make client-server communications explicit and flexible.

Long story short, in a few iterations we actually made an app that had 100% stability rating on Crashlytics (previously we had only 80-90%) for almost its entire lifespan (which was a few months, but still) and with ~14K active users. There were some issues with specific versions of Android OS (v. 4.0.0 if I remember right), where OS didn't callback app's life-cycle hooks for whatever reason, but other than that the app was pretty resilient.

It was a very cool achievement. And our team came out first in _iOS vs android_ race for a change.

There were a lot of growing pains as well. In the end, I didn't like Dagger2 and this DI part of a SOLID design at all... To me, it fell into the category of **'get it right the first time'** which is very time-consuming and stressful. Analysis paralysis is a big deal, and it feels extremely unrewarding and unimpactful when about 30% of your time is spent on making interfaces and polishing DI-graphs.

I had several problems with Realm early on with how it manages its DB instances, and with handling its life-data-objects across threads. But the major one was with Realm being unable to support [recursively nested objects](https://github.com/realm/realm-java/issues/5383) and/or [VM projections](https://github.com/realm/realm-java/issues/5426) which would've enabled us to make naturally-hierarchical truly domain-driven solutions. But oh well... still had to normalize data in some way or to compensate with views/selectors (which sort of defeated the point of moving away from SQL actually).

> Couldn't always get what you want I guess.

I don't remember how exactly it happened, but at some point, I've started to work on another kiosk using **Electron and React** instead of Android. It was probably had something to do with cutting costs on kiosk hardware of all things.

To everyone's surprise, I'm sure, it has happened to be the most effective and most gratifying way of producing kiosk apps in general.

I was blown away with how powerful and easy to use these tools were especially compared to our Android stack. Stuff that we've been working on for weeks, was done within mere days, and just by me alone...

> This was the turning point when I started to preach React, and componential architecture in general, to everyone.

We also tried to work with React Native at some point, but deemed it too risky to migrate at the time, unfortunately... React Native was so unstable, you could reliably crash your application by composing components in a certain way (something to do with touchable opacity and debug runtime sync issues).

Still, React was the King, and for the last half a year or so I've been mostly working with ReactJS solutions, teaching the team how to React, and trying to create kiosk-builder utility to mostly automate kiosks development.

Which was partially done -- I had the core figured out, it has been able to generate accurate presentations given a valid data-set, but I didn't finish DB-builder utility in time.

At a certain point, I had a major disagreement with our management with how the company should handle development process, what we should focus on next, and what should we learn from our previous projects and mistakes.

Looking back at it, I think working at Maugry was the most interesting and most gratifying experience overall. Thank you, fellas, you are cool.

---

# Story - part 4 (React, Redux, Elm)

I relocated again. I was heavily researching React and everything around it, trying to understand what made it such a great tool. I was also peeking into Elm.

Interestingly, the first time I've seen mentions of Elm and MVU architecture was way back when I've just started tinkering with clean architecture and SOLID design. Back then, Elm seemed scarier to me than a clean-SOLID, but this time around I learned that Elm design actually inspired React-Redux development!

Who would've thought, right?

---

I was hired by **LTD Andersen** as a Web-dev merc from July 2018 to February 2019. I actually wanted to work in a product-oriented company but I was sort of sold on the idea I would be able to work with any company and on any project I would like.

I was mostly working on 2 major projects. The first one was a **React + Redux** based app and I was making a dashboard module: customizable rich form builder, every element of which could be a simple input, or a layout component, or another rich form as well.

The most interesting things about this project were its size, how quickly it grew, and how well it scaled (comparatively). In its core the project was the same content-builder utility I have been working on previously at Maugry, so I already knew how to get started with it. But I haven't been able to experiment much with Redux before, and now it really seemed more like a requirement.

Redux is cool. Not only in how it streamlines communication for your components, but also in how it allows you to inject components with data almost like a DI-tool (but much easier and more explicit). And with pure components and connect-HoCs you can achieve fine-grained optimization: you will be able to re-render only those components which data is affected and nothing else.

Redux is also kinda bad. Vanilla Redux that is. The most annoying quality of it is its verbosity and the fact it wont solve a more complex cases for you. Contrary to what I just stated above, at a certain point, Redux starts to scale very poorly. These pesky action constants and action creators, that it sort of forces you to make, just become unmanageable. At a certain point, you will completely lose the mental map of how your actions are connected to their creators, reducers, and components, especially if you are working with a less experienced team... Also, if you would want to manage communications more complex than a ping-pong (1 request -- 1 result), you would definitely want to look at more advanced tools -- middleware -- like thunk, saga, or observable (I've tried them all, but I stayed with sagas for this project). So, I, personally, wouldn't recommend building a huge Redux-based app without the help of a statically typed language (like Typescript or ReasonML) at the very least. At a certain point, doesn't matter how well you organize, navigating and remembering actions becomes a huge pain.

It speaks volume, when the creator of Redux, Dan Abramov, expressed disappointment in what its tool came to be (or how people use it). Researching and getting to know Redux sparked a very interesting dilemma: manage an app' state entirely in global state and dumb down all your components; or use global state only for _app' essentials_ and do everything else locally. What is better and why?

It seems, like Dan and Co are leaning heavily on the second solution, while **Elm**, the thing Redux development was inspired with, chose the first path.

The second project I worked on, was a Typescript-React-Redux app, half-stuck migrating to **Elm**. This project I'm not allowed to talk much about at all, so I'll be focusing on the technology.

**Elm is great**. If you haven't seen it in action, but have some experience with React and Redux, you could think of it like a component-based statically-typed solution for building Web applications, with components being pure functions without the ability to hold local state, and with Redux-reducers being a fundamental part of the Elm' architecture.

Elm is a functional language, but it only implements a subset of features from the functional paradigm and lambda-calculus. The Elm' selling point is **'if it compiles, it works'**, which, from my experience, seems to be true. But what I've found really cool about Elm is that it will actually forces you, no matter what you do, to design your app top-down from the data (model), to communication (actions/updates), to presentation (view). 

MVU design is very strict, but very concise, compact and elegant at the same time. And with the help of the functional features like forced purity, complete immutability, non-existence of nullable-types (like null and undefined), **type-variant**, etc. -- creating and pattern-matching your actions becomes a trivial task.

With Elm your communicational layer wont feel like an additional thing you opted for, you will really be able to design a Web application like a finite-state machine from start to finish and guarantee it works.

Unfortunately, while working with huge **React + Redux** and **Elm** apps is super cool, I’ve learned I do not particularly like doing outsource.

## So what's next?

Today I'm still very interested in React, especially in its new core feature -- React hooks; I'm interested in Elm and Elm/React-like solutions (ReasonML-React); I'm interested in hybrid cross-platform containers like PWA, or frameworks like ReactNative. I'm somewhat intrigued by Elixir. I'm researching functional stuff.

---

# UPD: Story - part 5 (xstate)

There's a lot to tell about government agencies and their contractors, and how they work, and motivations behind what and how they do their stuff, but... suffice to say, working with them is probably the most frustrating experience I've ever had. Period. Please, never again.

On the more positive note, I've found a new crush: **xstate** and statecharts. It is probably **the** missing link between functional and component-based programming. It allows for completely independent, completely decoupled state-management. Agent-model is awesome even if a very old concept, but the implementation is what's important here. Before **xstate** there was nothing even comparably comprehensive on the web-market. The most notable implementations are java's **AKKA** and of course **Erlang** (BEAM platform and languages). But the web had almost nothing of the sort, and now it has **xstate**. There's also **robot**, but it doesn't look like it has the momentum to propel itself to become popular.

The missing thing here for the web-platform is threads. Even though we have workers -- they are not good enough (yet?) to be used to dynamically delegate a lot of work to them. So CPU-resource-management is not gonna be a thing for now for the web development. But, at some point...?